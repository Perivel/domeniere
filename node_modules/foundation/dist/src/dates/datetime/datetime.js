import moment from "moment";
import 'moment-timezone';
import { DateException } from './../exceptions/date.exception';
import { Timezone } from "./../../geography/geography.module";
export class DateTime {
    constructor(value, timezone = Timezone.UTC()) {
        if (!value) {
            throw new DateException();
        }
        const utcDate = new Date(Date.UTC(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes(), value.getSeconds(), value.getMilliseconds()));
        this.date = moment.utc(utcDate).toDate();
        this.tz = timezone;
    }
    static Now(timezone = Timezone.UTC()) {
        return new DateTime(new Date(), timezone);
    }
    static FromTimestamp(timestamp, timezone = Timezone.UTC()) {
        return new DateTime(timestamp.value(), timezone);
    }
    addDays(numDays) {
        return new DateTime(this.getMomentDate().add(numDays, 'days').toDate(), this.timezone());
    }
    addHours(numHours) {
        return new DateTime(this.getMomentDate().add(numHours, 'hours').toDate(), this.timezone());
    }
    addMinutes(numMinutes) {
        return new DateTime(this.getMomentDate().add(numMinutes, 'minutes').toDate(), this.timezone());
    }
    addMonths(numMonths) {
        return new DateTime(this.getMomentDate().add(numMonths, 'M').toDate(), this.timezone());
    }
    addYears(numYears) {
        return new DateTime(this.getMomentDate().add(numYears, 'y').toDate(), this.timezone());
    }
    day() {
        const utc = this.getMomentDate();
        const tzConverted = utc.tz(this.timezone().id());
        return Number(tzConverted.format("D"));
    }
    isAfter(suspect) {
        let isAfter = false;
        if (suspect instanceof DateTime) {
            const other = suspect;
            isAfter = this.getMomentDate().isAfter(other.getMomentDate());
        }
        return isAfter;
    }
    isBefore(suspect) {
        let isBefore = false;
        if (suspect instanceof DateTime) {
            const otherCreated = suspect;
            isBefore = this.getMomentDate().isBefore(otherCreated.getMomentDate());
        }
        return isBefore;
    }
    equals(suspect) {
        let isEqual = false;
        if (suspect instanceof DateTime) {
            const other = suspect;
            isEqual = this.getMomentDate().isSame(other.getMomentDate()) && this.timezone().equals(other.timezone());
        }
        return isEqual;
    }
    month() {
        const utc = this.getMomentDate();
        const tzConverted = utc.tz(this.timezone().id());
        return Number(tzConverted.format("M"));
    }
    subtractDays(numDays) {
        return new DateTime(this.getMomentDate().subtract(numDays, 'd').toDate(), this.timezone());
    }
    subtractHours(numHours) {
        return new DateTime(this.getMomentDate().subtract(numHours, 'h').toDate(), this.timezone());
    }
    subtractMinutes(numMinutes) {
        return new DateTime(this.getMomentDate().subtract(numMinutes, 'm').toDate(), this.timezone());
    }
    subtractMonths(numMonths) {
        return new DateTime(this.getMomentDate().subtract(numMonths, 'M').toDate(), this.timezone());
    }
    subtractYears(numYears) {
        return new DateTime(this.getMomentDate().subtract(numYears, 'y').toDate(), this.timezone());
    }
    timezone() {
        return this.tz;
    }
    toUtc() {
        return new DateTime(this.value());
    }
    toTimezone(timezone) {
        return new DateTime(this.value(), timezone);
    }
    utcString() {
        return this.getMomentDate().format();
    }
    value() {
        const utc = this.getMomentDate();
        const tzConverted = utc.tz(this.timezone().id());
        return new Date(this.utcString());
    }
    year() {
        const utc = this.getMomentDate();
        const tzConverted = utc.tz(this.timezone().id());
        return Number(this.getMomentDate().format("YYYY"));
    }
    getMomentDate() {
        return moment.utc(this.date);
    }
}

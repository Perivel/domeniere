import { QueueInterface } from "./queue.interface";

/**
 * Queue
 * 
 * Queue is a data structure that follows the LIFO principle.
 */

export class Queue<T> implements QueueInterface<T> {

    private _values: Array<T>;

    constructor() {
        this._values = new Array<T>();
    }

    /**
     * clear()
     * 
     * clear() clears the queue.
     */

    public clear(): void {
        this._values = new Array<T>();
    }

    /**
     * dequeue()
     * 
     * dequeue() removes the next item in the queue.
     */

    public dequeue(): T | null {
        let value: T|null = null;

        if (!this.isEmpty()) {
            value = this._values[0];
            this._values = this._values.filter((value, index) => index !== 0);
        }

        return value;
    }

    /**
     * enqueue()
     * 
     * enqueue() inserts an item into the queue.
     * @param value the value to insert.
     */

    public enqueue(value: T): void {
        this._values.push(value);
    } 

    /**
     * isEmpty()
     * 
     * isEmpty() determines if the queue is empty.
     */

    public isEmpty(): boolean {
        return this.size() === 0;
    }

    /**
     * peek()
     * 
     * peek() gets the next item in the queue, but does not remove it.
     */
    public peek(): T {
        return this._values[0];
    }

    /**
     * size()
     * 
     * size() gets the number of elements in the queue.
     */
    public size(): number {
        return this._values.length;
    }

    /**
     * toArray()
     * 
     * toArray() converts the queue to an array.
     */
    public toArray(): Array<T> {
        const arr = new Array<T>();
        this._values.forEach(value => arr.push(value));
        return arr;
    }
}